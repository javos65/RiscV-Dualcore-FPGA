// >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
// ------------------------------------------------------------------
// Copyright (c) 2019-2023 by Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// ------------------------------------------------------------------
//
// IMPORTANT: THIS FILE IS USED BY OR GENERATED BY the LATTICE PROPEL
// DEVELOPMENT SUITE, WHICH INCLUDES PROPEL BUILDER AND PROPEL SDK.
//
// Lattice grants permission to use this code pursuant to the
// terms of the Lattice Propel License Agreement.
//
// DISCLAIMER:
//
//  LATTICE MAKES NO WARRANTIES ON THIS FILE OR ITS CONTENTS, WHETHER
//  EXPRESSED, IMPLIED, STATUTORY, OR IN ANY PROVISION OF THE LATTICE
//  PROPEL LICENSE AGREEMENT OR COMMUNICATION WITH LICENSEE, AND LATTICE 
//  SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF MERCHANTABILITY OR
//  FITNESS FOR A PARTICULAR PURPOSE.  LATTICE DOES NOT WARRANT THAT THE
//  FUNCTIONS CONTAINED HEREIN WILL MEET LICENSEE'S REQUIREMENTS, OR THAT
//  LICENSEE'S OPERATION OF ANY DEVICE, SOFTWARE OR SYSTEM USING THIS FILE
//  OR ITS CONTENTS WILL BE UNINTERRUPTED OR ERROR FREE, OR THAT DEFECTS
//  HEREIN WILL BE CORRECTED.  LICENSEE ASSUMES RESPONSIBILITY FOR 
//  SELECTION OF MATERIALS TO ACHIEVE ITS INTENDED RESULTS, AND FOR THE
//  PROPER INSTALLATION, USE, AND RESULTS OBTAINED THEREFROM.  LICENSEE
//  ASSUMES THE ENTIRE RISK OF THE FILE AND ITS CONTENTS PROVING DEFECTIVE
//  OR FAILING TO PERFORM PROPERLY AND IN SUCH EVENT, LICENSEE SHALL 
//  ASSUME THE ENTIRE COST AND RISK OF ANY REPAIR, SERVICE, CORRECTION, OR
//  ANY OTHER LIABILITIES OR DAMAGES CAUSED BY OR ASSOCIATED WITH THE 
//  SOFTWARE.  IN NO EVENT SHALL LATTICE BE LIABLE TO ANY PARTY FOR DIRECT,
//  INDIRECT,SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST
//  PROFITS, ARISING OUT OF THE USE OF THIS FILE OR ITS CONTENTS, EVEN IF
//  LATTICE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. LATTICE'S
//  SOLE LIABILITY, AND LICENSEE'S SOLE REMEDY, IS SET FORTH ABOVE.  
//  LATTICE DOES NOT WARRANT OR REPRESENT THAT THIS FILE, ITS CONTENTS OR
//  USE THEREOF DOES NOT INFRINGE ON THIRD PARTIES' INTELLECTUAL PROPERTY
//  RIGHTS, INCLUDING ANY PATENT. IT IS THE USER'S RESPONSIBILITY TO VERIFY
//  THE USER SOFTWARE DESIGN FOR CONSISTENCY AND FUNCTIONALITY THROUGH THE
//  USE OF FORMAL SOFTWARE VALIDATION METHODS.
// ------------------------------------------------------------------


//CPU1


#include "gpio.h"
#include "hal.h"
#include "utils.h"
#include <stdio.h>
#include "sys_platform.h"

#if (defined LSCC_STDIO_UART_APB) && (defined UART_INST_BASE_ADDR)
#include "uart.h"

struct uart_instance uart_core_uart;
#endif
#ifndef _UART_NO_INTERRUPTS_
#include "pic.h"
#endif

struct gpio_instance gpio_inst;

// global pointers and Definitions for to DualPort use CPU1

#define DP_EMPTY		0	// Flag indicating buffer is empty (read and not yey re written
#define CPU_BUSY		1	// DP Cpu status indicates busy, no time to read or write DP
#define CPU_READY		0	// DP Cpu status indicates ready, polling and handling DP
#define DP_SIZE 		64

uint8_t *DPcpu0_status = (uint8_t*) DUALPORT_INST_BASE_ADDR;    			// status register THIS cpu  = cpu0. read/write
uint8_t *DPcpu1_status = (uint8_t*) (DUALPORT_INST_BASE_ADDR +1); 			// status register OTHER cpu = cpu1. read only

uint8_t *DPread_size = (uint8_t*) (DUALPORT_INST_BASE_ADDR+2);    			// flag cpu0 indicates data bytes in read buffer
uint8_t *DPwrite_size = (uint8_t*) (DUALPORT_INST_BASE_ADDR +3); 			// flag cpu1 indicates data bytes in write buffer
uint8_t *DPread_buffer = (uint8_t*) (DUALPORT_INST_BASE_ADDR+4);  			// 128 bytes buffer from cpu0 : written by cpu0, to be read cpu1
uint8_t *DPwrite_buffer  = (uint8_t*) (DUALPORT_INST_BASE_ADDR+5+DP_SIZE);	// 128 bytes buffer from cpu1 : written by cpu1, to be read cpu0

uint8_t Greadbuffer[DP_SIZE];
uint16_t Gpending_readsize=0;

static void bsp_init(void)
{
	//initialize GPIO
	gpio_inst.instance_name = GPIO1_INST_NAME;
	gpio_init(&gpio_inst, GPIO1_INST_BASE_ADDR, GPIO1_INST_LINES_NUM, GPIO1_INST_GPIO_DIRS);

	 //init DP Interface
	delay(200);
	*DPwrite_size = DP_EMPTY;
	*DPcpu1_status = CPU_READY;

}

uint8_t DPPoll_request()
{
uint16_t t,s=0;
char c;
	if( *DPread_size != DP_EMPTY ) // check if there is data to read
		 	 {
		 	 s= *DPread_size;
		 	 if(s <= DP_SIZE) // check valid size
		 	 	 {
		 		 for(t=0;t<s;t++)
		 	 	 	{
		 			Greadbuffer[t]= (char) *(DPread_buffer+t); // read data to buffer
		 	 	 	}
		 	 	 }
			 else s=0;
	 		 *DPread_size=DP_EMPTY; // set DP flag  data read.
	 		 Gpending_readsize = s; // set local flag
		 	 }
return(s);
}

uint8_t DPSend_feedback()
{
uint16_t t,s=0;
char c;
if (Gpending_readsize !=0 )	 		// check if a local reply is pending
	if( *DPwrite_size == DP_EMPTY ) // check if last reply was read
		{
		s = Gpending_readsize;
		for(t=0;t<s;t++) // create reply data string of characters
			{
			  *(DPwrite_buffer+t) = 32 + (Greadbuffer[t]^(t%8))%94; // create coded reply
			}
		*DPwrite_size = s; 	// flag the data size that is ready
		Gpending_readsize =0;  // alter local flag
		 }
return(s);
}


int main(void) {
	static uint8_t idx = 0;
	static uint32_t pin_state = 0xFFFFFFFF; // 32 bit register for 8 bit GPIO ... for just one bit :)

	bsp_init();

	while (true) {
		gpio_input_get(&gpio_inst, idx, &pin_state);
		if (pin_state&0x00000001) {*DPcpu1_status = CPU_READY;}
		else {*DPcpu1_status = CPU_BUSY;} // user button pressed to gnd : set to busy

		if (RTL_SIM) {
			delay(1);
		} else {
			delay(100);
		}

		if (*DPcpu1_status == CPU_READY) // only serve requests if READY-STATE
			{
			DPPoll_request();
			DPSend_feedback();
			}
	}

	return 0;
}

